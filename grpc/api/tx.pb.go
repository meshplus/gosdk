// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tx.proto

package api

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CommonReq struct {
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Auth      *Auth  `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth,omitempty"`
	Params    []byte `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
	TCert     string `protobuf:"bytes,4,opt,name=tCert,proto3" json:"tCert,omitempty"`
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *CommonReq) Reset()         { *m = CommonReq{} }
func (m *CommonReq) String() string { return proto.CompactTextString(m) }
func (*CommonReq) ProtoMessage()    {}
func (*CommonReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{0}
}
func (m *CommonReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonReq.Merge(m, src)
}
func (m *CommonReq) XXX_Size() int {
	return m.Size()
}
func (m *CommonReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonReq.DiscardUnknown(m)
}

var xxx_messageInfo_CommonReq proto.InternalMessageInfo

func (m *CommonReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CommonReq) GetAuth() *Auth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *CommonReq) GetParams() []byte {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *CommonReq) GetTCert() string {
	if m != nil {
		return m.TCert
	}
	return ""
}

func (m *CommonReq) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type CommonRes struct {
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Code      int64  `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	CodeDesc  string `protobuf:"bytes,3,opt,name=codeDesc,proto3" json:"codeDesc,omitempty"`
	Result    []byte `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CommonRes) Reset()         { *m = CommonRes{} }
func (m *CommonRes) String() string { return proto.CompactTextString(m) }
func (*CommonRes) ProtoMessage()    {}
func (*CommonRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{1}
}
func (m *CommonRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonRes.Merge(m, src)
}
func (m *CommonRes) XXX_Size() int {
	return m.Size()
}
func (m *CommonRes) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonRes.DiscardUnknown(m)
}

var xxx_messageInfo_CommonRes proto.InternalMessageInfo

func (m *CommonRes) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CommonRes) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CommonRes) GetCodeDesc() string {
	if m != nil {
		return m.CodeDesc
	}
	return ""
}

func (m *CommonRes) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

type Auth struct {
	Address   string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Signature string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Auth) Reset()         { *m = Auth{} }
func (m *Auth) String() string { return proto.CompactTextString(m) }
func (*Auth) ProtoMessage()    {}
func (*Auth) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{2}
}
func (m *Auth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Auth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Auth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Auth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auth.Merge(m, src)
}
func (m *Auth) XXX_Size() int {
	return m.Size()
}
func (m *Auth) XXX_DiscardUnknown() {
	xxx_messageInfo_Auth.DiscardUnknown(m)
}

var xxx_messageInfo_Auth proto.InternalMessageInfo

func (m *Auth) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Auth) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Auth) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type SendTxArgs struct {
	From               string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To                 string   `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Value              int64    `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	Payload            string   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	Signature          string   `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp          int64    `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Simulate           bool     `protobuf:"varint,7,opt,name=simulate,proto3" json:"simulate,omitempty"`
	Nonce              int64    `protobuf:"varint,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Extra              string   `protobuf:"bytes,9,opt,name=extra,proto3" json:"extra,omitempty"`
	VmType             string   `protobuf:"bytes,10,opt,name=vmType,proto3" json:"vmType,omitempty"`
	Opcode             int32    `protobuf:"varint,11,opt,name=opcode,proto3" json:"opcode,omitempty"`
	SnapshotID         string   `protobuf:"bytes,12,opt,name=snapshotID,proto3" json:"snapshotID,omitempty"`
	ExtraIDInt64Array  []int64  `protobuf:"varint,13,rep,packed,name=extraIDInt64Array,proto3" json:"extraIDInt64Array,omitempty"`
	ExtraIDStringArray []string `protobuf:"bytes,14,rep,name=extraIDStringArray,proto3" json:"extraIDStringArray,omitempty"`
	CName              string   `protobuf:"bytes,15,opt,name=cName,proto3" json:"cName,omitempty"`
}

func (m *SendTxArgs) Reset()         { *m = SendTxArgs{} }
func (m *SendTxArgs) String() string { return proto.CompactTextString(m) }
func (*SendTxArgs) ProtoMessage()    {}
func (*SendTxArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{3}
}
func (m *SendTxArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTxArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTxArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTxArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTxArgs.Merge(m, src)
}
func (m *SendTxArgs) XXX_Size() int {
	return m.Size()
}
func (m *SendTxArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTxArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SendTxArgs proto.InternalMessageInfo

func (m *SendTxArgs) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *SendTxArgs) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *SendTxArgs) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *SendTxArgs) GetPayload() string {
	if m != nil {
		return m.Payload
	}
	return ""
}

func (m *SendTxArgs) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *SendTxArgs) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SendTxArgs) GetSimulate() bool {
	if m != nil {
		return m.Simulate
	}
	return false
}

func (m *SendTxArgs) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SendTxArgs) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func (m *SendTxArgs) GetVmType() string {
	if m != nil {
		return m.VmType
	}
	return ""
}

func (m *SendTxArgs) GetOpcode() int32 {
	if m != nil {
		return m.Opcode
	}
	return 0
}

func (m *SendTxArgs) GetSnapshotID() string {
	if m != nil {
		return m.SnapshotID
	}
	return ""
}

func (m *SendTxArgs) GetExtraIDInt64Array() []int64 {
	if m != nil {
		return m.ExtraIDInt64Array
	}
	return nil
}

func (m *SendTxArgs) GetExtraIDStringArray() []string {
	if m != nil {
		return m.ExtraIDStringArray
	}
	return nil
}

func (m *SendTxArgs) GetCName() string {
	if m != nil {
		return m.CName
	}
	return ""
}

type ReceiptResult struct {
	Version         string         `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	TxHash          string         `protobuf:"bytes,2,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	VMType          string         `protobuf:"bytes,3,opt,name=VMType,proto3" json:"VMType,omitempty"`
	ContractAddress string         `protobuf:"bytes,4,opt,name=ContractAddress,proto3" json:"ContractAddress,omitempty"`
	ContractName    string         `protobuf:"bytes,5,opt,name=ContractName,proto3" json:"ContractName,omitempty"`
	GasUsed         int64          `protobuf:"varint,6,opt,name=GasUsed,proto3" json:"GasUsed,omitempty"`
	Ret             string         `protobuf:"bytes,7,opt,name=Ret,proto3" json:"Ret,omitempty"`
	Log             []*LogTrans    `protobuf:"bytes,8,rep,name=Log,proto3" json:"Log,omitempty"`
	Valid           bool           `protobuf:"varint,9,opt,name=Valid,proto3" json:"Valid,omitempty"`
	ErrorMsg        string         `protobuf:"bytes,10,opt,name=ErrorMsg,proto3" json:"ErrorMsg,omitempty"`
	Oracles         []*OracleTrans `protobuf:"bytes,11,rep,name=Oracles,proto3" json:"Oracles,omitempty"`
}

func (m *ReceiptResult) Reset()         { *m = ReceiptResult{} }
func (m *ReceiptResult) String() string { return proto.CompactTextString(m) }
func (*ReceiptResult) ProtoMessage()    {}
func (*ReceiptResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{4}
}
func (m *ReceiptResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiptResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiptResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiptResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiptResult.Merge(m, src)
}
func (m *ReceiptResult) XXX_Size() int {
	return m.Size()
}
func (m *ReceiptResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiptResult.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiptResult proto.InternalMessageInfo

func (m *ReceiptResult) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ReceiptResult) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *ReceiptResult) GetVMType() string {
	if m != nil {
		return m.VMType
	}
	return ""
}

func (m *ReceiptResult) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *ReceiptResult) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *ReceiptResult) GetGasUsed() int64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *ReceiptResult) GetRet() string {
	if m != nil {
		return m.Ret
	}
	return ""
}

func (m *ReceiptResult) GetLog() []*LogTrans {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *ReceiptResult) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *ReceiptResult) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *ReceiptResult) GetOracles() []*OracleTrans {
	if m != nil {
		return m.Oracles
	}
	return nil
}

type LogTrans struct {
	Address     string   `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Topics      []string `protobuf:"bytes,2,rep,name=Topics,proto3" json:"Topics,omitempty"`
	Data        string   `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	BlockNumber uint64   `protobuf:"varint,4,opt,name=BlockNumber,proto3" json:"BlockNumber,omitempty"`
	BlockHash   string   `protobuf:"bytes,5,opt,name=BlockHash,proto3" json:"BlockHash,omitempty"`
	TxHash      string   `protobuf:"bytes,6,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	TxIndex     uint64   `protobuf:"varint,7,opt,name=TxIndex,proto3" json:"TxIndex,omitempty"`
	Index       uint64   `protobuf:"varint,8,opt,name=Index,proto3" json:"Index,omitempty"`
}

func (m *LogTrans) Reset()         { *m = LogTrans{} }
func (m *LogTrans) String() string { return proto.CompactTextString(m) }
func (*LogTrans) ProtoMessage()    {}
func (*LogTrans) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{5}
}
func (m *LogTrans) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogTrans) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogTrans.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogTrans) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogTrans.Merge(m, src)
}
func (m *LogTrans) XXX_Size() int {
	return m.Size()
}
func (m *LogTrans) XXX_DiscardUnknown() {
	xxx_messageInfo_LogTrans.DiscardUnknown(m)
}

var xxx_messageInfo_LogTrans proto.InternalMessageInfo

func (m *LogTrans) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *LogTrans) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *LogTrans) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *LogTrans) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *LogTrans) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *LogTrans) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *LogTrans) GetTxIndex() uint64 {
	if m != nil {
		return m.TxIndex
	}
	return 0
}

func (m *LogTrans) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type OracleTrans struct {
	URL             string            `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	Method          string            `protobuf:"bytes,2,opt,name=Method,proto3" json:"Method,omitempty"`
	Header          map[string]string `protobuf:"bytes,3,rep,name=Header,proto3" json:"Header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Body            string            `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	TxHash          string            `protobuf:"bytes,5,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	BizID           string            `protobuf:"bytes,6,opt,name=BizID,proto3" json:"BizID,omitempty"`
	CallBackAddress string            `protobuf:"bytes,7,opt,name=CallBackAddress,proto3" json:"CallBackAddress,omitempty"`
	CallBackMethod  string            `protobuf:"bytes,8,opt,name=CallBackMethod,proto3" json:"CallBackMethod,omitempty"`
	UUID            string            `protobuf:"bytes,9,opt,name=UUID,proto3" json:"UUID,omitempty"`
	ContractAddress string            `protobuf:"bytes,10,opt,name=ContractAddress,proto3" json:"ContractAddress,omitempty"`
}

func (m *OracleTrans) Reset()         { *m = OracleTrans{} }
func (m *OracleTrans) String() string { return proto.CompactTextString(m) }
func (*OracleTrans) ProtoMessage()    {}
func (*OracleTrans) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fd2153dc07d3b5c, []int{6}
}
func (m *OracleTrans) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleTrans) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleTrans.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleTrans) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleTrans.Merge(m, src)
}
func (m *OracleTrans) XXX_Size() int {
	return m.Size()
}
func (m *OracleTrans) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleTrans.DiscardUnknown(m)
}

var xxx_messageInfo_OracleTrans proto.InternalMessageInfo

func (m *OracleTrans) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *OracleTrans) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *OracleTrans) GetHeader() map[string]string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *OracleTrans) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *OracleTrans) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *OracleTrans) GetBizID() string {
	if m != nil {
		return m.BizID
	}
	return ""
}

func (m *OracleTrans) GetCallBackAddress() string {
	if m != nil {
		return m.CallBackAddress
	}
	return ""
}

func (m *OracleTrans) GetCallBackMethod() string {
	if m != nil {
		return m.CallBackMethod
	}
	return ""
}

func (m *OracleTrans) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *OracleTrans) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*CommonReq)(nil), "protos.CommonReq")
	proto.RegisterType((*CommonRes)(nil), "protos.CommonRes")
	proto.RegisterType((*Auth)(nil), "protos.Auth")
	proto.RegisterType((*SendTxArgs)(nil), "protos.SendTxArgs")
	proto.RegisterType((*ReceiptResult)(nil), "protos.ReceiptResult")
	proto.RegisterType((*LogTrans)(nil), "protos.LogTrans")
	proto.RegisterType((*OracleTrans)(nil), "protos.OracleTrans")
	proto.RegisterMapType((map[string]string)(nil), "protos.OracleTrans.HeaderEntry")
}

func init() { proto.RegisterFile("tx.proto", fileDescriptor_0fd2153dc07d3b5c) }

var fileDescriptor_0fd2153dc07d3b5c = []byte{
	// 1084 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x17, 0x4d, 0xbb, 0x9d, 0xd8, 0xbe, 0xce, 0x24, 0x99, 0xfa, 0xa2, 0x4f, 0xad, 0x30, 0x78, 0x8c,
	0x17, 0xc8, 0x0b, 0x88, 0x42, 0x06, 0xc1, 0x30, 0x20, 0x84, 0x1d, 0x8f, 0x12, 0x8b, 0x78, 0xd0,
	0x54, 0x7e, 0x56, 0x6c, 0x6a, 0xba, 0x0b, 0xa7, 0x95, 0xee, 0xaa, 0x9e, 0xaa, 0xea, 0xc8, 0xe6,
	0x29, 0x90, 0x58, 0x20, 0xc4, 0x0b, 0xf0, 0x02, 0xbc, 0x03, 0xcb, 0x59, 0x66, 0x89, 0x92, 0xe7,
	0x40, 0x42, 0xf5, 0xd3, 0x8e, 0xed, 0x44, 0x90, 0x78, 0xe5, 0x3a, 0xa7, 0xeb, 0xde, 0x3a, 0xf7,
	0xdc, 0x5b, 0xdd, 0x86, 0xaa, 0x1a, 0x6d, 0x67, 0x82, 0x2b, 0x8e, 0x56, 0xcc, 0x8f, 0x6c, 0xfd,
	0xe2, 0x41, 0x6d, 0x8f, 0xa7, 0x29, 0x67, 0x98, 0xbe, 0x45, 0x4f, 0xa0, 0xc6, 0x48, 0x4a, 0x65,
	0x46, 0x42, 0x1a, 0x78, 0x4d, 0xaf, 0x5d, 0xc3, 0x37, 0x04, 0x6a, 0x42, 0x99, 0xe4, 0xea, 0x2c,
	0x28, 0x35, 0xbd, 0x76, 0x7d, 0x77, 0xd5, 0x66, 0x92, 0xdb, 0x9d, 0x5c, 0x9d, 0x61, 0xf3, 0x04,
	0xfd, 0x1f, 0x56, 0x32, 0x22, 0x48, 0x2a, 0x03, 0xbf, 0xe9, 0xb5, 0x57, 0xb1, 0x43, 0x68, 0x13,
	0x96, 0xd5, 0x1e, 0x15, 0x2a, 0x28, 0x9b, 0x9c, 0x16, 0xe8, 0xd3, 0x64, 0x3c, 0x64, 0x44, 0xe5,
	0x82, 0x06, 0xcb, 0xf6, 0xb4, 0x09, 0xd1, 0x7a, 0x7b, 0x23, 0x4c, 0xfe, 0x87, 0x30, 0x04, 0xe5,
	0x90, 0x47, 0xd4, 0x08, 0xf3, 0xb1, 0x59, 0xa3, 0x2d, 0xa8, 0xea, 0xdf, 0x1e, 0x95, 0xa1, 0x11,
	0x53, 0xc3, 0x13, 0xac, 0x65, 0x0a, 0x2a, 0xf3, 0xc4, 0xea, 0x59, 0xc5, 0x0e, 0xb5, 0xbe, 0x87,
	0xb2, 0x2e, 0x06, 0x05, 0x50, 0x21, 0x51, 0x24, 0xa8, 0x94, 0xee, 0xac, 0x02, 0x6a, 0x1d, 0x2a,
	0x4e, 0xa9, 0x54, 0x24, 0xcd, 0xdc, 0x71, 0x37, 0xc4, 0x6c, 0x41, 0xfe, 0x7c, 0x41, 0xbf, 0xfb,
	0x00, 0x47, 0x94, 0x45, 0xc7, 0xa3, 0x8e, 0x18, 0x4a, 0x2d, 0xfa, 0x07, 0xc1, 0x53, 0x77, 0x82,
	0x59, 0xa3, 0x35, 0x28, 0x29, 0x6e, 0xf2, 0xd6, 0x70, 0x49, 0x71, 0xed, 0xdb, 0x05, 0x49, 0x72,
	0x9b, 0xcc, 0xc7, 0x16, 0x68, 0x79, 0x19, 0x19, 0x27, 0x9c, 0x44, 0xce, 0xcf, 0x02, 0xfe, 0xbb,
	0xa3, 0xb3, 0xe2, 0x57, 0xe6, 0xc5, 0x6f, 0x41, 0x55, 0xc6, 0x69, 0x9e, 0x10, 0x45, 0x83, 0x4a,
	0xd3, 0x6b, 0x57, 0xf1, 0x04, 0x6b, 0x1d, 0x8c, 0xb3, 0x90, 0x06, 0x55, 0xab, 0xc3, 0x00, 0xcd,
	0xd2, 0x91, 0x12, 0x24, 0xa8, 0xd9, 0xae, 0x1a, 0xa0, 0xcd, 0xbd, 0x48, 0x8f, 0xc7, 0x19, 0x0d,
	0xc0, 0xd0, 0x0e, 0x69, 0x9e, 0x67, 0xa6, 0x4d, 0xf5, 0xa6, 0xd7, 0x5e, 0xc6, 0x0e, 0xa1, 0x06,
	0x80, 0x64, 0x24, 0x93, 0x67, 0x5c, 0xf5, 0x7b, 0xc1, 0xaa, 0x89, 0x99, 0x62, 0xd0, 0x47, 0xf0,
	0xd8, 0x24, 0xee, 0xf7, 0xfa, 0x4c, 0x7d, 0xf6, 0x69, 0x47, 0x08, 0x32, 0x0e, 0x1e, 0x35, 0xfd,
	0xb6, 0x8f, 0x6f, 0x3f, 0x40, 0xdb, 0x80, 0x1c, 0x79, 0xa4, 0x44, 0xcc, 0x86, 0x76, 0xfb, 0x5a,
	0xd3, 0x6f, 0xd7, 0xf0, 0x1d, 0x4f, 0x74, 0x0d, 0xe1, 0x2b, 0x92, 0xd2, 0x60, 0xdd, 0xd6, 0x60,
	0x40, 0xeb, 0xb2, 0x04, 0x8f, 0x30, 0x0d, 0x69, 0x9c, 0x29, 0x6c, 0x46, 0x43, 0x7b, 0x7e, 0x4a,
	0x85, 0x8c, 0x39, 0x2b, 0x46, 0xc2, 0x41, 0x5d, 0xd7, 0xf1, 0xe8, 0x80, 0xc8, 0x33, 0xd7, 0x37,
	0x87, 0x34, 0x7f, 0x3a, 0x30, 0x3e, 0xd8, 0x49, 0x70, 0x08, 0xb5, 0x61, 0x7d, 0x8f, 0x33, 0x25,
	0x48, 0xa8, 0x3a, 0x6e, 0xc8, 0x6c, 0x17, 0xe7, 0x69, 0xd4, 0x82, 0xd5, 0x82, 0x32, 0x12, 0x6d,
	0x43, 0x67, 0x38, 0xad, 0x6b, 0x9f, 0xc8, 0x13, 0x49, 0x23, 0xd7, 0xd1, 0x02, 0xa2, 0x0d, 0xf0,
	0x31, 0x55, 0xa6, 0x95, 0x35, 0xac, 0x97, 0xa8, 0x05, 0xfe, 0x21, 0x1f, 0x06, 0xd5, 0xa6, 0xdf,
	0xae, 0xef, 0x6e, 0x14, 0xd7, 0xf7, 0x90, 0x0f, 0x8f, 0x05, 0x61, 0x12, 0xeb, 0x87, 0xda, 0x8f,
	0x53, 0x92, 0xc4, 0x91, 0xe9, 0x69, 0x15, 0x5b, 0xa0, 0x67, 0xe3, 0xa5, 0x10, 0x5c, 0x0c, 0xe4,
	0xd0, 0x75, 0x75, 0x82, 0xd1, 0xc7, 0x50, 0xf9, 0x4e, 0x90, 0x30, 0xa1, 0x32, 0xa8, 0x9b, 0xcc,
	0xff, 0x2b, 0x32, 0x5b, 0xda, 0x26, 0x2f, 0xf6, 0xb4, 0x2e, 0x3d, 0xa8, 0x16, 0x47, 0x6a, 0xf5,
	0x9d, 0xd9, 0x8b, 0x56, 0xd4, 0xae, 0x5d, 0xe5, 0x59, 0x1c, 0xca, 0xa0, 0x64, 0x7a, 0xe7, 0x90,
	0xbe, 0x35, 0x3d, 0xa2, 0x88, 0xf3, 0xd4, 0xac, 0x51, 0x13, 0xea, 0xdd, 0x84, 0x87, 0xe7, 0xaf,
	0xf2, 0xf4, 0x0d, 0x15, 0xc6, 0xcd, 0x32, 0x9e, 0xa6, 0xf4, 0xe4, 0x1b, 0x68, 0xda, 0xe4, 0xee,
	0xc5, 0x84, 0x98, 0xea, 0xe0, 0xca, 0x4c, 0x07, 0x03, 0xa8, 0x1c, 0x8f, 0xfa, 0x2c, 0xa2, 0x23,
	0xe3, 0x62, 0x19, 0x17, 0x50, 0xbb, 0x64, 0xf9, 0xaa, 0xe1, 0x2d, 0x68, 0xfd, 0x5d, 0x82, 0xfa,
	0x54, 0xcd, 0xba, 0x03, 0x27, 0xf8, 0xd0, 0x55, 0xa6, 0x97, 0xfa, 0xa4, 0x01, 0x55, 0x67, 0x3c,
	0x2a, 0x66, 0xc5, 0x22, 0xf4, 0x39, 0xac, 0x1c, 0x50, 0x12, 0x51, 0x11, 0xf8, 0xc6, 0xc2, 0xa7,
	0x77, 0x58, 0xb8, 0x6d, 0x77, 0xbc, 0x64, 0x4a, 0x8c, 0xb1, 0xdb, 0xae, 0xed, 0xe8, 0xf2, 0x68,
	0xec, 0x26, 0xc8, 0xac, 0xa7, 0xca, 0x59, 0x9e, 0x29, 0x67, 0x13, 0x96, 0xbb, 0xf1, 0x8f, 0xfd,
	0x9e, 0xab, 0xd2, 0x02, 0x33, 0x8e, 0x24, 0x49, 0xba, 0x24, 0x3c, 0x2f, 0x5a, 0x51, 0x71, 0xe3,
	0x38, 0x4b, 0xa3, 0x0f, 0x61, 0xad, 0xa0, 0x5c, 0x11, 0x55, 0xb3, 0x71, 0x8e, 0xd5, 0x9a, 0x4e,
	0x4e, 0xfa, 0x3d, 0xf7, 0x56, 0x30, 0xeb, 0xbb, 0x86, 0x1e, 0xee, 0x1c, 0xfa, 0xad, 0x2f, 0xa0,
	0x3e, 0x55, 0xa8, 0xf6, 0xf0, 0x9c, 0x8e, 0x0b, 0x0f, 0xcf, 0xe9, 0xf8, 0xe6, 0x9d, 0x68, 0x2d,
	0xb4, 0xe0, 0x45, 0xe9, 0xb9, 0xb7, 0xfb, 0x9b, 0x07, 0x68, 0x5f, 0x64, 0x61, 0x27, 0x8b, 0x8d,
	0x63, 0x24, 0x54, 0xfa, 0x82, 0x7e, 0x09, 0xeb, 0xe6, 0xb5, 0x3b, 0x45, 0x3d, 0x2e, 0xfc, 0x9d,
	0x7c, 0xfa, 0xb6, 0x6e, 0x51, 0xb2, 0xed, 0xed, 0x78, 0xe8, 0x00, 0x9e, 0xcc, 0x05, 0x63, 0xaa,
	0x72, 0xc1, 0xdc, 0xdb, 0xe1, 0xfe, 0x99, 0x76, 0xff, 0x28, 0xc3, 0xba, 0x53, 0x57, 0xd4, 0x8c,
	0x5e, 0xc0, 0x5a, 0x8f, 0x66, 0x09, 0x1f, 0x4f, 0x98, 0xfb, 0x2b, 0xdb, 0x87, 0xf7, 0x66, 0x63,
	0x17, 0x14, 0xa6, 0x45, 0xf4, 0xd9, 0x05, 0x3f, 0xa7, 0x8b, 0x89, 0x98, 0x8d, 0x5d, 0x54, 0xc4,
	0x57, 0xb0, 0x31, 0x20, 0x31, 0x53, 0x24, 0x66, 0x0b, 0xc8, 0xe8, 0xc3, 0xfb, 0xf3, 0xd1, 0x8b,
	0x0a, 0xf9, 0x06, 0x36, 0x07, 0x84, 0x91, 0xe1, 0xa4, 0xa2, 0xee, 0xf8, 0x94, 0x2b, 0xfa, 0x80,
	0x0c, 0x03, 0xf8, 0xe0, 0xae, 0x0c, 0x8b, 0xce, 0xcd, 0xaf, 0x1e, 0x80, 0x9b, 0x9b, 0x5e, 0x1c,
	0xa1, 0xaf, 0x01, 0xe9, 0x81, 0xec, 0xf5, 0x7b, 0x8b, 0x0d, 0xf4, 0xb7, 0xf0, 0xf4, 0x76, 0xfc,
	0xa2, 0xda, 0x7e, 0x2e, 0x41, 0xcd, 0x69, 0x1b, 0xbc, 0x46, 0x3b, 0x50, 0xc5, 0x74, 0x18, 0x4b,
	0x45, 0xc5, 0xfd, 0x72, 0xa0, 0x5d, 0x80, 0x13, 0xf6, 0xc0, 0x98, 0xe7, 0xb0, 0xb1, 0x4f, 0x55,
	0x27, 0x49, 0x5e, 0xe7, 0x34, 0xa7, 0xfa, 0x23, 0x28, 0xef, 0x19, 0xf9, 0x09, 0x54, 0xf6, 0x38,
	0x93, 0x79, 0x7a, 0xcf, 0x6e, 0xee, 0x78, 0xe8, 0x19, 0xd4, 0x8f, 0x14, 0xcf, 0x1e, 0x14, 0xd6,
	0x0d, 0xfe, 0xbc, 0x6a, 0x78, 0xef, 0xae, 0x1a, 0xde, 0x5f, 0x57, 0x0d, 0xef, 0xa7, 0xeb, 0xc6,
	0xd2, 0xbb, 0xeb, 0xc6, 0xd2, 0xe5, 0x75, 0x63, 0xe9, 0x8d, 0xfd, 0xd7, 0xfd, 0xec, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x9e, 0x22, 0x00, 0x6c, 0x88, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GrpcApiTransactionClient is the client API for GrpcApiTransaction service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrpcApiTransactionClient interface {
	SendTransaction(ctx context.Context, opts ...grpc.CallOption) (GrpcApiTransaction_SendTransactionClient, error)
	SendTransactionReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiTransaction_SendTransactionReturnReceiptClient, error)
}

type grpcApiTransactionClient struct {
	cc *grpc.ClientConn
}

func NewGrpcApiTransactionClient(cc *grpc.ClientConn) GrpcApiTransactionClient {
	return &grpcApiTransactionClient{cc}
}

func (c *grpcApiTransactionClient) SendTransaction(ctx context.Context, opts ...grpc.CallOption) (GrpcApiTransaction_SendTransactionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiTransaction_serviceDesc.Streams[0], "/protos.GrpcApiTransaction/SendTransaction", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiTransactionSendTransactionClient{stream}
	return x, nil
}

type GrpcApiTransaction_SendTransactionClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiTransactionSendTransactionClient struct {
	grpc.ClientStream
}

func (x *grpcApiTransactionSendTransactionClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiTransactionSendTransactionClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiTransactionClient) SendTransactionReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiTransaction_SendTransactionReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiTransaction_serviceDesc.Streams[1], "/protos.GrpcApiTransaction/SendTransactionReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiTransactionSendTransactionReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiTransaction_SendTransactionReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiTransactionSendTransactionReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiTransactionSendTransactionReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiTransactionSendTransactionReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GrpcApiTransactionServer is the server API for GrpcApiTransaction service.
type GrpcApiTransactionServer interface {
	SendTransaction(GrpcApiTransaction_SendTransactionServer) error
	SendTransactionReturnReceipt(GrpcApiTransaction_SendTransactionReturnReceiptServer) error
}

// UnimplementedGrpcApiTransactionServer can be embedded to have forward compatible implementations.
type UnimplementedGrpcApiTransactionServer struct {
}

func (*UnimplementedGrpcApiTransactionServer) SendTransaction(srv GrpcApiTransaction_SendTransactionServer) error {
	return status.Errorf(codes.Unimplemented, "method SendTransaction not implemented")
}
func (*UnimplementedGrpcApiTransactionServer) SendTransactionReturnReceipt(srv GrpcApiTransaction_SendTransactionReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method SendTransactionReturnReceipt not implemented")
}

func RegisterGrpcApiTransactionServer(s *grpc.Server, srv GrpcApiTransactionServer) {
	s.RegisterService(&_GrpcApiTransaction_serviceDesc, srv)
}

func _GrpcApiTransaction_SendTransaction_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiTransactionServer).SendTransaction(&grpcApiTransactionSendTransactionServer{stream})
}

type GrpcApiTransaction_SendTransactionServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiTransactionSendTransactionServer struct {
	grpc.ServerStream
}

func (x *grpcApiTransactionSendTransactionServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiTransactionSendTransactionServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiTransaction_SendTransactionReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiTransactionServer).SendTransactionReturnReceipt(&grpcApiTransactionSendTransactionReturnReceiptServer{stream})
}

type GrpcApiTransaction_SendTransactionReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiTransactionSendTransactionReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiTransactionSendTransactionReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiTransactionSendTransactionReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GrpcApiTransaction_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.GrpcApiTransaction",
	HandlerType: (*GrpcApiTransactionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendTransaction",
			Handler:       _GrpcApiTransaction_SendTransaction_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SendTransactionReturnReceipt",
			Handler:       _GrpcApiTransaction_SendTransactionReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tx.proto",
}

// GrpcApiContractClient is the client API for GrpcApiContract service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrpcApiContractClient interface {
	DeployContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_DeployContractClient, error)
	DeployContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_DeployContractReturnReceiptClient, error)
	InvokeContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_InvokeContractClient, error)
	InvokeContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_InvokeContractReturnReceiptClient, error)
	MaintainContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_MaintainContractClient, error)
	MaintainContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_MaintainContractReturnReceiptClient, error)
	ManageContractByVote(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_ManageContractByVoteClient, error)
	ManageContractByVoteReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_ManageContractByVoteReturnReceiptClient, error)
}

type grpcApiContractClient struct {
	cc *grpc.ClientConn
}

func NewGrpcApiContractClient(cc *grpc.ClientConn) GrpcApiContractClient {
	return &grpcApiContractClient{cc}
}

func (c *grpcApiContractClient) DeployContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_DeployContractClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[0], "/protos.GrpcApiContract/DeployContract", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractDeployContractClient{stream}
	return x, nil
}

type GrpcApiContract_DeployContractClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractDeployContractClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractDeployContractClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractDeployContractClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) DeployContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_DeployContractReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[1], "/protos.GrpcApiContract/DeployContractReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractDeployContractReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiContract_DeployContractReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractDeployContractReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractDeployContractReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractDeployContractReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) InvokeContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_InvokeContractClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[2], "/protos.GrpcApiContract/InvokeContract", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractInvokeContractClient{stream}
	return x, nil
}

type GrpcApiContract_InvokeContractClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractInvokeContractClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractInvokeContractClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractInvokeContractClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) InvokeContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_InvokeContractReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[3], "/protos.GrpcApiContract/InvokeContractReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractInvokeContractReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiContract_InvokeContractReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractInvokeContractReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractInvokeContractReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractInvokeContractReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) MaintainContract(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_MaintainContractClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[4], "/protos.GrpcApiContract/MaintainContract", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractMaintainContractClient{stream}
	return x, nil
}

type GrpcApiContract_MaintainContractClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractMaintainContractClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractMaintainContractClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractMaintainContractClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) MaintainContractReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_MaintainContractReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[5], "/protos.GrpcApiContract/MaintainContractReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractMaintainContractReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiContract_MaintainContractReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractMaintainContractReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractMaintainContractReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractMaintainContractReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) ManageContractByVote(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_ManageContractByVoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[6], "/protos.GrpcApiContract/ManageContractByVote", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractManageContractByVoteClient{stream}
	return x, nil
}

type GrpcApiContract_ManageContractByVoteClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractManageContractByVoteClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractManageContractByVoteClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractManageContractByVoteClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiContractClient) ManageContractByVoteReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiContract_ManageContractByVoteReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiContract_serviceDesc.Streams[7], "/protos.GrpcApiContract/ManageContractByVoteReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiContractManageContractByVoteReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiContract_ManageContractByVoteReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiContractManageContractByVoteReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiContractManageContractByVoteReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiContractManageContractByVoteReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GrpcApiContractServer is the server API for GrpcApiContract service.
type GrpcApiContractServer interface {
	DeployContract(GrpcApiContract_DeployContractServer) error
	DeployContractReturnReceipt(GrpcApiContract_DeployContractReturnReceiptServer) error
	InvokeContract(GrpcApiContract_InvokeContractServer) error
	InvokeContractReturnReceipt(GrpcApiContract_InvokeContractReturnReceiptServer) error
	MaintainContract(GrpcApiContract_MaintainContractServer) error
	MaintainContractReturnReceipt(GrpcApiContract_MaintainContractReturnReceiptServer) error
	ManageContractByVote(GrpcApiContract_ManageContractByVoteServer) error
	ManageContractByVoteReturnReceipt(GrpcApiContract_ManageContractByVoteReturnReceiptServer) error
}

// UnimplementedGrpcApiContractServer can be embedded to have forward compatible implementations.
type UnimplementedGrpcApiContractServer struct {
}

func (*UnimplementedGrpcApiContractServer) DeployContract(srv GrpcApiContract_DeployContractServer) error {
	return status.Errorf(codes.Unimplemented, "method DeployContract not implemented")
}
func (*UnimplementedGrpcApiContractServer) DeployContractReturnReceipt(srv GrpcApiContract_DeployContractReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method DeployContractReturnReceipt not implemented")
}
func (*UnimplementedGrpcApiContractServer) InvokeContract(srv GrpcApiContract_InvokeContractServer) error {
	return status.Errorf(codes.Unimplemented, "method InvokeContract not implemented")
}
func (*UnimplementedGrpcApiContractServer) InvokeContractReturnReceipt(srv GrpcApiContract_InvokeContractReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method InvokeContractReturnReceipt not implemented")
}
func (*UnimplementedGrpcApiContractServer) MaintainContract(srv GrpcApiContract_MaintainContractServer) error {
	return status.Errorf(codes.Unimplemented, "method MaintainContract not implemented")
}
func (*UnimplementedGrpcApiContractServer) MaintainContractReturnReceipt(srv GrpcApiContract_MaintainContractReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method MaintainContractReturnReceipt not implemented")
}
func (*UnimplementedGrpcApiContractServer) ManageContractByVote(srv GrpcApiContract_ManageContractByVoteServer) error {
	return status.Errorf(codes.Unimplemented, "method ManageContractByVote not implemented")
}
func (*UnimplementedGrpcApiContractServer) ManageContractByVoteReturnReceipt(srv GrpcApiContract_ManageContractByVoteReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method ManageContractByVoteReturnReceipt not implemented")
}

func RegisterGrpcApiContractServer(s *grpc.Server, srv GrpcApiContractServer) {
	s.RegisterService(&_GrpcApiContract_serviceDesc, srv)
}

func _GrpcApiContract_DeployContract_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).DeployContract(&grpcApiContractDeployContractServer{stream})
}

type GrpcApiContract_DeployContractServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractDeployContractServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractDeployContractServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractDeployContractServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_DeployContractReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).DeployContractReturnReceipt(&grpcApiContractDeployContractReturnReceiptServer{stream})
}

type GrpcApiContract_DeployContractReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractDeployContractReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractDeployContractReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractDeployContractReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_InvokeContract_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).InvokeContract(&grpcApiContractInvokeContractServer{stream})
}

type GrpcApiContract_InvokeContractServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractInvokeContractServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractInvokeContractServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractInvokeContractServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_InvokeContractReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).InvokeContractReturnReceipt(&grpcApiContractInvokeContractReturnReceiptServer{stream})
}

type GrpcApiContract_InvokeContractReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractInvokeContractReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractInvokeContractReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractInvokeContractReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_MaintainContract_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).MaintainContract(&grpcApiContractMaintainContractServer{stream})
}

type GrpcApiContract_MaintainContractServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractMaintainContractServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractMaintainContractServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractMaintainContractServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_MaintainContractReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).MaintainContractReturnReceipt(&grpcApiContractMaintainContractReturnReceiptServer{stream})
}

type GrpcApiContract_MaintainContractReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractMaintainContractReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractMaintainContractReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractMaintainContractReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_ManageContractByVote_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).ManageContractByVote(&grpcApiContractManageContractByVoteServer{stream})
}

type GrpcApiContract_ManageContractByVoteServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractManageContractByVoteServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractManageContractByVoteServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractManageContractByVoteServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiContract_ManageContractByVoteReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiContractServer).ManageContractByVoteReturnReceipt(&grpcApiContractManageContractByVoteReturnReceiptServer{stream})
}

type GrpcApiContract_ManageContractByVoteReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiContractManageContractByVoteReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiContractManageContractByVoteReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiContractManageContractByVoteReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GrpcApiContract_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.GrpcApiContract",
	HandlerType: (*GrpcApiContractServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DeployContract",
			Handler:       _GrpcApiContract_DeployContract_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeployContractReturnReceipt",
			Handler:       _GrpcApiContract_DeployContractReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "InvokeContract",
			Handler:       _GrpcApiContract_InvokeContract_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "InvokeContractReturnReceipt",
			Handler:       _GrpcApiContract_InvokeContractReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "MaintainContract",
			Handler:       _GrpcApiContract_MaintainContract_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "MaintainContractReturnReceipt",
			Handler:       _GrpcApiContract_MaintainContractReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ManageContractByVote",
			Handler:       _GrpcApiContract_ManageContractByVote_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ManageContractByVoteReturnReceipt",
			Handler:       _GrpcApiContract_ManageContractByVoteReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tx.proto",
}

// GrpcApiDidClient is the client API for GrpcApiDid service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrpcApiDidClient interface {
	SendDIDTransaction(ctx context.Context, opts ...grpc.CallOption) (GrpcApiDid_SendDIDTransactionClient, error)
	SendDIDTransactionReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiDid_SendDIDTransactionReturnReceiptClient, error)
}

type grpcApiDidClient struct {
	cc *grpc.ClientConn
}

func NewGrpcApiDidClient(cc *grpc.ClientConn) GrpcApiDidClient {
	return &grpcApiDidClient{cc}
}

func (c *grpcApiDidClient) SendDIDTransaction(ctx context.Context, opts ...grpc.CallOption) (GrpcApiDid_SendDIDTransactionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiDid_serviceDesc.Streams[0], "/protos.GrpcApiDid/SendDIDTransaction", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiDidSendDIDTransactionClient{stream}
	return x, nil
}

type GrpcApiDid_SendDIDTransactionClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiDidSendDIDTransactionClient struct {
	grpc.ClientStream
}

func (x *grpcApiDidSendDIDTransactionClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiDidSendDIDTransactionClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiDidClient) SendDIDTransactionReturnReceipt(ctx context.Context, opts ...grpc.CallOption) (GrpcApiDid_SendDIDTransactionReturnReceiptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiDid_serviceDesc.Streams[1], "/protos.GrpcApiDid/SendDIDTransactionReturnReceipt", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiDidSendDIDTransactionReturnReceiptClient{stream}
	return x, nil
}

type GrpcApiDid_SendDIDTransactionReturnReceiptClient interface {
	Send(*CommonReq) error
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiDidSendDIDTransactionReturnReceiptClient struct {
	grpc.ClientStream
}

func (x *grpcApiDidSendDIDTransactionReturnReceiptClient) Send(m *CommonReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcApiDidSendDIDTransactionReturnReceiptClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GrpcApiDidServer is the server API for GrpcApiDid service.
type GrpcApiDidServer interface {
	SendDIDTransaction(GrpcApiDid_SendDIDTransactionServer) error
	SendDIDTransactionReturnReceipt(GrpcApiDid_SendDIDTransactionReturnReceiptServer) error
}

// UnimplementedGrpcApiDidServer can be embedded to have forward compatible implementations.
type UnimplementedGrpcApiDidServer struct {
}

func (*UnimplementedGrpcApiDidServer) SendDIDTransaction(srv GrpcApiDid_SendDIDTransactionServer) error {
	return status.Errorf(codes.Unimplemented, "method SendDIDTransaction not implemented")
}
func (*UnimplementedGrpcApiDidServer) SendDIDTransactionReturnReceipt(srv GrpcApiDid_SendDIDTransactionReturnReceiptServer) error {
	return status.Errorf(codes.Unimplemented, "method SendDIDTransactionReturnReceipt not implemented")
}

func RegisterGrpcApiDidServer(s *grpc.Server, srv GrpcApiDidServer) {
	s.RegisterService(&_GrpcApiDid_serviceDesc, srv)
}

func _GrpcApiDid_SendDIDTransaction_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiDidServer).SendDIDTransaction(&grpcApiDidSendDIDTransactionServer{stream})
}

type GrpcApiDid_SendDIDTransactionServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiDidSendDIDTransactionServer struct {
	grpc.ServerStream
}

func (x *grpcApiDidSendDIDTransactionServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiDidSendDIDTransactionServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcApiDid_SendDIDTransactionReturnReceipt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcApiDidServer).SendDIDTransactionReturnReceipt(&grpcApiDidSendDIDTransactionReturnReceiptServer{stream})
}

type GrpcApiDid_SendDIDTransactionReturnReceiptServer interface {
	Send(*CommonRes) error
	Recv() (*CommonReq, error)
	grpc.ServerStream
}

type grpcApiDidSendDIDTransactionReturnReceiptServer struct {
	grpc.ServerStream
}

func (x *grpcApiDidSendDIDTransactionReturnReceiptServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcApiDidSendDIDTransactionReturnReceiptServer) Recv() (*CommonReq, error) {
	m := new(CommonReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GrpcApiDid_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.GrpcApiDid",
	HandlerType: (*GrpcApiDidServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendDIDTransaction",
			Handler:       _GrpcApiDid_SendDIDTransaction_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SendDIDTransactionReturnReceipt",
			Handler:       _GrpcApiDid_SendDIDTransactionReturnReceipt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tx.proto",
}

// GrpcApiMQClient is the client API for GrpcApiMQ service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrpcApiMQClient interface {
	Register(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error)
	UnRegister(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error)
	GetAllQueueNames(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error)
	Consume(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (GrpcApiMQ_ConsumeClient, error)
	StopConsume(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error)
}

type grpcApiMQClient struct {
	cc *grpc.ClientConn
}

func NewGrpcApiMQClient(cc *grpc.ClientConn) GrpcApiMQClient {
	return &grpcApiMQClient{cc}
}

func (c *grpcApiMQClient) Register(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error) {
	out := new(CommonRes)
	err := c.cc.Invoke(ctx, "/protos.GrpcApiMQ/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grpcApiMQClient) UnRegister(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error) {
	out := new(CommonRes)
	err := c.cc.Invoke(ctx, "/protos.GrpcApiMQ/UnRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grpcApiMQClient) GetAllQueueNames(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error) {
	out := new(CommonRes)
	err := c.cc.Invoke(ctx, "/protos.GrpcApiMQ/GetAllQueueNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grpcApiMQClient) Consume(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (GrpcApiMQ_ConsumeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GrpcApiMQ_serviceDesc.Streams[0], "/protos.GrpcApiMQ/Consume", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcApiMQConsumeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GrpcApiMQ_ConsumeClient interface {
	Recv() (*CommonRes, error)
	grpc.ClientStream
}

type grpcApiMQConsumeClient struct {
	grpc.ClientStream
}

func (x *grpcApiMQConsumeClient) Recv() (*CommonRes, error) {
	m := new(CommonRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcApiMQClient) StopConsume(ctx context.Context, in *CommonReq, opts ...grpc.CallOption) (*CommonRes, error) {
	out := new(CommonRes)
	err := c.cc.Invoke(ctx, "/protos.GrpcApiMQ/StopConsume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GrpcApiMQServer is the server API for GrpcApiMQ service.
type GrpcApiMQServer interface {
	Register(context.Context, *CommonReq) (*CommonRes, error)
	UnRegister(context.Context, *CommonReq) (*CommonRes, error)
	GetAllQueueNames(context.Context, *CommonReq) (*CommonRes, error)
	Consume(*CommonReq, GrpcApiMQ_ConsumeServer) error
	StopConsume(context.Context, *CommonReq) (*CommonRes, error)
}

// UnimplementedGrpcApiMQServer can be embedded to have forward compatible implementations.
type UnimplementedGrpcApiMQServer struct {
}

func (*UnimplementedGrpcApiMQServer) Register(ctx context.Context, req *CommonReq) (*CommonRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedGrpcApiMQServer) UnRegister(ctx context.Context, req *CommonReq) (*CommonRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnRegister not implemented")
}
func (*UnimplementedGrpcApiMQServer) GetAllQueueNames(ctx context.Context, req *CommonReq) (*CommonRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllQueueNames not implemented")
}
func (*UnimplementedGrpcApiMQServer) Consume(req *CommonReq, srv GrpcApiMQ_ConsumeServer) error {
	return status.Errorf(codes.Unimplemented, "method Consume not implemented")
}
func (*UnimplementedGrpcApiMQServer) StopConsume(ctx context.Context, req *CommonReq) (*CommonRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopConsume not implemented")
}

func RegisterGrpcApiMQServer(s *grpc.Server, srv GrpcApiMQServer) {
	s.RegisterService(&_GrpcApiMQ_serviceDesc, srv)
}

func _GrpcApiMQ_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcApiMQServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.GrpcApiMQ/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcApiMQServer).Register(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrpcApiMQ_UnRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcApiMQServer).UnRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.GrpcApiMQ/UnRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcApiMQServer).UnRegister(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrpcApiMQ_GetAllQueueNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcApiMQServer).GetAllQueueNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.GrpcApiMQ/GetAllQueueNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcApiMQServer).GetAllQueueNames(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrpcApiMQ_Consume_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CommonReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GrpcApiMQServer).Consume(m, &grpcApiMQConsumeServer{stream})
}

type GrpcApiMQ_ConsumeServer interface {
	Send(*CommonRes) error
	grpc.ServerStream
}

type grpcApiMQConsumeServer struct {
	grpc.ServerStream
}

func (x *grpcApiMQConsumeServer) Send(m *CommonRes) error {
	return x.ServerStream.SendMsg(m)
}

func _GrpcApiMQ_StopConsume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcApiMQServer).StopConsume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.GrpcApiMQ/StopConsume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcApiMQServer).StopConsume(ctx, req.(*CommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _GrpcApiMQ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.GrpcApiMQ",
	HandlerType: (*GrpcApiMQServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _GrpcApiMQ_Register_Handler,
		},
		{
			MethodName: "UnRegister",
			Handler:    _GrpcApiMQ_UnRegister_Handler,
		},
		{
			MethodName: "GetAllQueueNames",
			Handler:    _GrpcApiMQ_GetAllQueueNames_Handler,
		},
		{
			MethodName: "StopConsume",
			Handler:    _GrpcApiMQ_StopConsume_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Consume",
			Handler:       _GrpcApiMQ_Consume_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "tx.proto",
}

func (m *CommonReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TCert) > 0 {
		i -= len(m.TCert)
		copy(dAtA[i:], m.TCert)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TCert)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Auth != nil {
		{
			size, err := m.Auth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CodeDesc) > 0 {
		i -= len(m.CodeDesc)
		copy(dAtA[i:], m.CodeDesc)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CodeDesc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Auth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendTxArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTxArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendTxArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CName) > 0 {
		i -= len(m.CName)
		copy(dAtA[i:], m.CName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ExtraIDStringArray) > 0 {
		for iNdEx := len(m.ExtraIDStringArray) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtraIDStringArray[iNdEx])
			copy(dAtA[i:], m.ExtraIDStringArray[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.ExtraIDStringArray[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.ExtraIDInt64Array) > 0 {
		dAtA3 := make([]byte, len(m.ExtraIDInt64Array)*10)
		var j2 int
		for _, num1 := range m.ExtraIDInt64Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTx(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x62
	}
	if m.Opcode != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Opcode))
		i--
		dAtA[i] = 0x58
	}
	if len(m.VmType) > 0 {
		i -= len(m.VmType)
		copy(dAtA[i:], m.VmType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VmType)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x40
	}
	if m.Simulate {
		i--
		if m.Simulate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Timestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReceiptResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiptResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiptResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Oracles) > 0 {
		for iNdEx := len(m.Oracles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Oracles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x52
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Log) > 0 {
		for iNdEx := len(m.Log) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Log[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Ret) > 0 {
		i -= len(m.Ret)
		copy(dAtA[i:], m.Ret)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ret)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GasUsed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VMType) > 0 {
		i -= len(m.VMType)
		copy(dAtA[i:], m.VMType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VMType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogTrans) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogTrans) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogTrans) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x40
	}
	if m.TxIndex != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TxIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Topics[iNdEx])
			copy(dAtA[i:], m.Topics[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Topics[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleTrans) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleTrans) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleTrans) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UUID) > 0 {
		i -= len(m.UUID)
		copy(dAtA[i:], m.UUID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UUID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CallBackMethod) > 0 {
		i -= len(m.CallBackMethod)
		copy(dAtA[i:], m.CallBackMethod)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CallBackMethod)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CallBackAddress) > 0 {
		i -= len(m.CallBackAddress)
		copy(dAtA[i:], m.CallBackAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CallBackAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BizID) > 0 {
		i -= len(m.BizID)
		copy(dAtA[i:], m.BizID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BizID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CommonReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Auth != nil {
		l = m.Auth.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TCert)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *CommonRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTx(uint64(m.Code))
	}
	l = len(m.CodeDesc)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *Auth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTx(uint64(m.Timestamp))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SendTxArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovTx(uint64(m.Value))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTx(uint64(m.Timestamp))
	}
	if m.Simulate {
		n += 2
	}
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VmType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Opcode != 0 {
		n += 1 + sovTx(uint64(m.Opcode))
	}
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ExtraIDInt64Array) > 0 {
		l = 0
		for _, e := range m.ExtraIDInt64Array {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	if len(m.ExtraIDStringArray) > 0 {
		for _, s := range m.ExtraIDStringArray {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.CName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *ReceiptResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VMType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovTx(uint64(m.GasUsed))
	}
	l = len(m.Ret)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Valid {
		n += 2
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Oracles) > 0 {
		for _, e := range m.Oracles {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *LogTrans) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovTx(uint64(m.BlockNumber))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TxIndex != 0 {
		n += 1 + sovTx(uint64(m.TxIndex))
	}
	if m.Index != 0 {
		n += 1 + sovTx(uint64(m.Index))
	}
	return n
}

func (m *OracleTrans) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BizID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CallBackAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CallBackMethod)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommonReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auth == nil {
				m.Auth = &Auth{}
			}
			if err := m.Auth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params[:0], dAtA[iNdEx:postIndex]...)
			if m.Params == nil {
				m.Params = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Auth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTxArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTxArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTxArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Simulate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Simulate = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opcode", wireType)
			}
			m.Opcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExtraIDInt64Array = append(m.ExtraIDInt64Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExtraIDInt64Array) == 0 {
					m.ExtraIDInt64Array = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExtraIDInt64Array = append(m.ExtraIDInt64Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraIDInt64Array", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraIDStringArray", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraIDStringArray = append(m.ExtraIDStringArray, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiptResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiptResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiptResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VMType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VMType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &LogTrans{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracles = append(m.Oracles, &OracleTrans{})
			if err := m.Oracles[len(m.Oracles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogTrans) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogTrans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogTrans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIndex", wireType)
			}
			m.TxIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleTrans) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleTrans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleTrans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallBackAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallBackAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallBackMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallBackMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
